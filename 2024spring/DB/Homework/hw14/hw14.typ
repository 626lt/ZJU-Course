#import "template.typ": *
#[
  #set align(center)
  #set text(font: "Source Han Sans")

  #v(5cm)
  #set text(size: 36pt)
  《数据库系统》\ 作业14

  #set text(font: ("Linux Libertine", "LXGW WenKai Mono"))
  #v(2cm)
  #set text(size: 15pt)
  #grid(
    columns: (80pt, 180pt),
    rows: (27pt, 27pt, 27pt, 27pt),
    [姓名：], [#uline[刘韬]],
    [学院：], [#uline[竺可桢学院]],
    [专业：], [#uline[人工智能]],
    [邮箱：], [#uline[3220103422\@zju.edu.cn]],
  )

  #v(2cm)
  #set text(size: 18pt)
  #grid(
    columns: (100pt, 200pt),
    [日期：], [#uline[#datetime.today().display()]],
  )

  #pagebreak()
]

#show: doc => dbhw(doc)

== 18.1

两阶段锁定协议（2PL）是一种用于保证事务并发执行时的一致性的协议。它分为两个阶段：扩展阶段和收缩阶段。在扩展阶段，事务可以获取更多的锁，但不能释放任何锁。在收缩阶段，事务可以释放锁，但不能获取新的锁。这两个阶段的分界点被称为锁点。

两阶段锁定协议可以确保冲突的可序列化性，原因如下：

假设存在环 $T_0 -> T_1 -> T_2 -> ... -> T_(n-1) -> T_0$，设 $alpha_i$ 是 $T_i$ 得到最后一个锁的时间，那么有 $alpha_0 < alpha_1 < alpha_2 < ... < alpha_(n-1) < alpha_0$，这是因为 $T_i$ 在 $T_(i+1)$ 得到最后一个锁之前不能释放锁，而 $T_(i+1)$ 在 $T_i$ 得到最后一个锁之前不能获取锁。所以矛盾，因此不存在环。所以两阶段锁定协议可以确保冲突的可序列化性。

== 18.7

=== a

增量锁的存在使得如果两个事务对同一个item都有I mode lock，那么这两个顺序可以交换，剩余仍然同上 18.1

=== b

在增量模式锁中，事务可以在需要时获取更多的锁，而不是在开始时就获取所有需要的锁。这样，事务可以在其他事务释放锁后立即获取这些锁，而不需要等待其他事务完成。

这种策略可以增加并发性，原因如下：

减少等待时间：事务可以在需要时获取锁，这意味着事务可以在其他事务释放锁后立即获取这些锁，而不需要等待其他事务完成。这可以减少事务的等待时间，从而增加并发性。

提高资源利用率：在增量模式锁中，事务只在需要时获取锁，这意味着在任何时刻，只有真正需要某个资源的事务才会持有该资源的锁。这可以提高资源的利用率，从而增加并发性。

减少锁冲突：在增量模式锁中，事务可以在需要时获取更多的锁，这可以减少事务之间的锁冲突，从而增加并发性。

== 18.18

+ 避免死锁：在严格的两阶段锁定协议中，事务在其结束时一次性释放所有的锁，这可以减少死锁的可能性。因为事务不会在持有一些锁的同时尝试获取更多的锁，所以不太可能出现两个或更多的事务互相等待对方释放锁的情况。

+ 保证可串行化：严格的两阶段锁定协议可以保证事务的冲突可串行化。这是因为在任何时刻，对于任何数据项，最多只有一个事务可以对其进行写操作，或者有多个事务可以同时进行读操作。

+ 简化恢复过程：严格的两阶段锁定协议可以简化数据库的恢复过程。因为事务在结束时一次性释放所有的锁，所以在事务结束后，不需要对其进行任何进一步的处理。这使得在系统崩溃后的恢复过程更加简单和高效。